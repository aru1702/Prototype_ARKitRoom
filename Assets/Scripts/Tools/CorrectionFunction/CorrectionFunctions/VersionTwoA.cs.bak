using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using WeightFunction;


namespace CorrectionFunctions
{
    /// <summary>
    /// Version TWO side A will update the marker in NewARScene, and record the camera data.
    /// Camera data will records the time on travel only.
    /// There will be A and B scalar parameter as priority for each weight, with total of 1.00 (100%).
    /// This function needs marker data (GT and C), objects data, and camera data (as mentioned above).
    /// Enable this function by attach this script to GameObject (enable/disable as trigger)
    /// </summary>
    public class VersionTwoA : MonoBehaviour
    {
        List<MarkerLocation> m_Markers;
        List<CameraTrajectoryData> m_CameraTrajectoryData;
        List<GameObject> m_Objects;
        List<GameObject> m_MarkersGroundTruth;
        List<Vector3> m_InitObjectsLocations;

        ObjectToMarkers OTM;
        CameraTrajectoryAndTime CTT;


        [SerializeField]
        [Tooltip("AR camera game object.")]
        GameObject m_ARCamera;

        [SerializeField]
        [Tooltip("To import object location.")]
        GameObject m_LoadObjectManager;

        [SerializeField]
        [Tooltip("To import marker location in runtime.")]
        GameObject m_ImageTrackingManager;

        [SerializeField]
        [Tooltip("Update runtime per interval in seconds.")]
        float m_UpdateInterval = 1.0f;


        [SerializeField]
        [Range(0, 1)]
        [Tooltip("A is object to marker distance weight priority, 0 to 1 in float")]
        float m_OTMPriority = 1.0f;

        [SerializeField]
        [Tooltip("Scalar multiplier for object to marker distance weight function.")]
        float m_OTMScalarWeight = 1.0f;

        [SerializeField]
        [Range(0, 1)]
        [Tooltip("B is camera data time on travel distance weight priority, 0 to 1 in float")]
        float m_CTTTimePriority = 1.0f;

        [SerializeField]
        [Tooltip("Scalar multiplier for camera data time on travel distance weight function.")]
        float m_CTTScalarWeight = 1.0f;

        [Tooltip("Only active this if not want to use GlobalConfig configuration")]
        [SerializeField]
        bool m_UnityEditorMode = false;
        public void SetUnityEditorModeTrue() { m_UnityEditorMode = true; }

        [SerializeField]
        bool m_WeightDataSave = false;

        [SerializeField]
        GameObject m_WeightDataScript;


        // Trigger when GameObject is enabled
        private void OnEnable()
        {
            // initialization
            m_Markers = new();
            m_CameraTrajectoryData = new();
            OTM = new();
            CTT = new();
            GetMarkerGroundTruth();

            // get global configuration
            if (!m_UnityEditorMode)
            {
                m_OTMScalarWeight = GlobalConfig.OTM_SCALAR;
                m_OTMPriority = GlobalConfig.OTM_PRIORITY;
                m_CTTScalarWeight = GlobalConfig.CTTtime_SCALAR;
                m_CTTTimePriority = GlobalConfig.CTTtime_PRIORITY;
            }
            else
            {
                GlobalConfig.OTM_SCALAR = m_OTMScalarWeight;
                GlobalConfig.OTM_PRIORITY = m_OTMPriority;
                GlobalConfig.CTTtime_SCALAR = m_CTTScalarWeight;
                GlobalConfig.CTTtime_PRIORITY = m_CTTTimePriority;
            }

            // please be know that this function only works with NewARScene case
            // check the called script (GetComponent) on each manager
            ImportObjectsNewARScene();
            StartCoroutine(WhereAttachedToNewARScene());
        }

        IEnumerator WhereAttachedToNewARScene()
        {
            while (true)
            {
                yield return new WaitForSeconds(m_UpdateInterval);
                UpdateCameraData();
                Main();
            }
        }

        bool alreadyDebug = false;

        void Main()
        {
            // check if image tracking has detected a marker
            bool marker_has_update = m_ImageTrackingManager
                .GetComponent<NewARSceneImageTrackingCorrection>()
                .GetImageTargetUpdateStatus();
            if (!marker_has_update)
            {
                /*
                    CTT.GoToNextMarker();
                    //CTT.ResetTotalTime();   // Dec 21th, 2022 -- version 2

                    if (m_WeightDataSave)
                    {
                        var SWD = m_WeightDataScript.GetComponent<Test_NewARScene_ImgTracking_SaveWeightData>();
                        SWD.SetUpdateData(false);
                    }
                */

                // if no marker update, set current marker as previous marker
                CTT.SetPrevMarkerName(CTT.GetNowMarkerName());

                alreadyDebug = false;

                return;
            }

            // get all markers on runtime
            var all_markers = m_ImageTrackingManager
                .GetComponent<NewARSceneImageTrackingCorrection>()
                .GetImageTrackedList();
            if (all_markers.Count > 0) { AddOrUpdateMarkerRuntime(all_markers); }

            // get only detected marker on runtime
            //var runtime_markers = m_ImageTrackingManager
            //    .GetComponent<NewARSceneImageTrackingCorrection>()
            //    .GetImageTrackedListWithRemove();
            //if (runtime_markers.Count > 0) { AddOrUpdateCameraData(runtime_markers); }
            var previous_marker = m_ImageTrackingManager
                .GetComponent<NewARSceneImageTrackingCorrection>()
                .GetPreviousMarkerTracked();
            if (all_markers.Count > 0) { AddOrUpdateCameraData(all_markers, previous_marker); }

            //Debug.Log("all: " + all_markers.Count + ", rt: " + runtime_markers.Count);

            // calculate marker error vector
            List<Vector3> MED = StaticFunctions.MarkerErrorDifference(m_Markers);
            List<CustomTransform> MCT = StaticFunctions.ExtractToCustomTransform(m_Markers);

            // get weights from ObjectToMarker function
            OTM.SetMarkers(MCT);
            OTM.SetObjects(m_Objects);
            var otm_weights = OTM.GetAllWeights(MathFunctions.SIGMOID, true, true, m_OTMScalarWeight);

            // get raw data from CameraTrajectoryAndTime function
            CTT.SetCameraTrajectoryData(m_CameraTrajectoryData);
            var CTT_raw_data = CTT.GetCameraTrajectoryData();
            List<float> camera_times = new();
            foreach (var d in CTT_raw_data) { camera_times.Add(d.Camera_travel_time); }
            var norm_camera_times = MathFunctions.NormalizedMany(camera_times);

            // multiply into weights from ObjectToMarker
            List<float[]> new_weights = new();
            List<float[]> norm_new_weights = new();
            for (int i = 0; i < otm_weights.Count; i++)            
            {
                List<float> new_w = new();
                for (int j = 0; j < otm_weights[i].Length; j++)
                {
                    var result = norm_camera_times[j] * otm_weights[i][j];
                    new_w.Add(result);
                }
                new_weights.Add(new_w.ToArray());

                // normalized after calculation
                var norm = MathFunctions.NormalizedMany(new_w);
                norm_new_weights.Add(norm.ToArray());
            }

            // get new vector with norm_new_weights
            // calculate new object location with weight
            var new_vector = StaticFunctions.CorrectedVector(m_InitObjectsLocations, norm_new_weights, MED);
            for (int i = 0; i < m_Objects.Count; i++)
            {
                m_Objects[i].transform.position = new_vector[i];
            }

            // debugging process
            if (!alreadyDebug)
            {
                GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(otm_weights), "otm_weights");
                GlobalDebugging.DebugLogListFloat(camera_times, "raw camera times");
                GlobalDebugging.DebugLogListFloat(norm_camera_times, "normalized raw camera times");
                GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(new_weights), "new_weights");
                GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(norm_new_weights), "norm_new_weights");

                var SWD = m_WeightDataScript.GetComponent<Test_NewARScene_ImgTracking_SaveWeightData>();
                SWD.AddAllDebugInputListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(otm_weights), "otm_weights");
                SWD.AddAllDebugInputListFloat(camera_times, "raw camera times");
                SWD.AddAllDebugInputListFloat(norm_camera_times, "normalized raw camera times");
                SWD.AddAllDebugInputListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(new_weights), "new_weights");
                SWD.AddAllDebugInputListFloatArray(Test_OnlyAxisObjectGet.MarkerAxisThenObject1To16ForDec212022(norm_new_weights), "norm_new_weights");

                alreadyDebug = true;
            }

/* Dec 21th, 2022
 * We will try to use average without Sigmoid function
 * We will use to as priority knowledge
 * 
            // get weights from CameraTrajectoryAndTime function 
            CTT.SetMarkers(MCT);
            CTT.SetCameraTrajectoryData(m_CameraTrajectoryData);
            CTT.AverageTimeLimiter();
            var ctt_weights = CTT.GetCameraTimeWeights(MathFunctions.SIGMOID,
                                                       true, true,
                                                       m_CTTScalarWeight);
            //GlobalDebugging.DebugLogListFloat(ctt_weights, "before invert");
            for (int i = 0; i < ctt_weights.Count; i++) { ctt_weights[i] = 1 - ctt_weights[i]; }
            //GlobalDebugging.DebugLogListFloat(ctt_weights, "after invert");

            // Dec 21th, 2022 -- version 1
            // START

            // calculate new object location with weight
            //var new_vector_v1 = StaticFunctions.CorrectedVector(m_InitObjectsLocations, otm_weights, MED);
            //for (int i = 0; i < m_Objects.Count; i++)
            //{
            //    m_Objects[i].transform.position = new_vector_v1[i];
            //}
            //return;

            // Dec 21th, 2022 -- version 1
            // RESULT: passed

            // Dec 21th, 2022 -- version 2
            // START

            //var time = CTT.GetTotalTime();
            //if (time <= 10 / m_CTTScalarWeight)
            //{
            //    var new_vector_v1 = StaticFunctions.CorrectedVector(m_InitObjectsLocations, otm_weights, MED);
            //    for (int i = 0; i < m_Objects.Count; i++)
            //    {
            //        m_Objects[i].transform.position = new_vector_v1[i];
            //    }
            //    return;
            //}
            //else
            //{
            //    List<float[]> new_ctt_weights_v2 = new();
            //    for (int i = 0; i < otm_weights.Count; i++) { new_ctt_weights_v2.Add(ctt_weights.ToArray()); }
            //    var add_v2 = MathFunctions.AddTwoListFloatArray(otm_weights, new_ctt_weights_v2);
            //    List<float[]> norm_v2 =  new(); foreach (var ar in add_v2) { norm_v2.Add(MathFunctions.NormalizedMany(ar)); }
            //    var cv_2 = StaticFunctions.CorrectedVector(m_InitObjectsLocations, add_v2, MED);
            //    for (int i = 0; i < m_Objects.Count; i++) { m_Objects[i].transform.position = cv_2[i]; }
            //    return;
            //}

            // Dec 21th, 2022 -- version 2
            // RESULT 1: reset at everytime, also if function must be inverted
            // RESULT 2: failed, is same as previous strange result


            // since CTT function only has single array of List<float>
            // we convert so it has the same size of OTM List<float[]>
            List<float[]> new_ctt_weights = new();
            for (int i = 0; i < otm_weights.Count; i++)
            {
                new_ctt_weights.Add(ctt_weights.ToArray());
            }

            // calculate the weight priority
            var priority = GetPriority(true, m_OTMPriority, m_CTTTimePriority);

            //GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(otm_weights), "ObjectToMarkers on VersionTwoA");
            //GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(new_ctt_weights), "CameraTrajectoryAndTime (time only) on VersionTwoA");
            GlobalDebugging.DebugLogListFloat(priority, "Weight priority on VersionTwoA");
            
            // convert each weight into WeightsAndScalar class
            WeightsAndScalar WAS_otm_weights = new(otm_weights, priority[0]);
            WeightsAndScalar WAS_ctt_weights = new(new_ctt_weights, priority[1]);

            WAS_otm_weights.ApplyScalarToWeights();
            WAS_ctt_weights.ApplyScalarToWeights();
            var adding_result = MathFunctions.AddTwoListFloatArray(WAS_otm_weights.Weights, WAS_ctt_weights.Weights);
            List<float[]> result_normalized = new();
            foreach (var ar in adding_result) { result_normalized.Add(MathFunctions.NormalizedMany(ar)); }

            var new_vector = StaticFunctions.CorrectedVector(m_InitObjectsLocations, result_normalized, MED);

            //// calculate new object location with weight
            //var new_vector = StaticFunctions.CorrectedVectorV2(m_InitObjectsLocations, MED,
            //                 WAS_otm_weights,   // argument 1
            //                 WAS_ctt_weights);  // argument 2

            // apply new vector to objects
            for (int i = 0; i < m_Objects.Count; i++)
            {
                m_Objects[i].transform.position = new_vector[i];
            }

            if (m_UnityEditorMode)
            {
                //TestAdding(otm_weights, new_ctt_weights);
                TestAdding(WAS_otm_weights, WAS_ctt_weights);
            }

            if (m_WeightDataSave)
            {
                var SWD = m_WeightDataScript.GetComponent<Test_NewARScene_ImgTracking_SaveWeightData>();
                SWD.InsertDataAsFollowDec19("otm_weights", m_CameraTrajectoryData, otm_weights);
                SWD.InsertDataAsFollowDec19("ctt_weights", m_CameraTrajectoryData, new_ctt_weights);
                var new_weights = WeightsAndScalar.AddMultipleWeightList(WAS_otm_weights, WAS_ctt_weights);
                SWD.InsertDataAsFollowDec19("new_weights", m_CameraTrajectoryData, new_weights);
                SWD.InsertDataAsFollowDec19("result_normalized", m_CameraTrajectoryData, result_normalized);
                SWD.SetUpdateData(true);
            }

            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(result_normalized), "result normalized");
*/
        }

        void UpdateCameraData()
        {
            if (m_ARCamera != null)
            {
                var camera_pos = m_ARCamera.transform.position;
                CTT.SetCameraNow(camera_pos);
                CTT.UpdateCameraDistance(true);
            }

            CTT.AutomaticUpdateTotalTime();
        }

        void AddOrUpdateMarkerRuntime(List<CustomTransform> markers)
        {
            // initialization
            var temp_obj = new GameObject();
            var origin = GlobalConfig.PlaySpaceOriginGO;
            temp_obj.transform.SetParent(origin.transform);

            // add new marker into list
            if (m_Markers.Count < markers.Count)
            {
                for (int i = m_Markers.Count; i < markers.Count; i++)
                {
                    MarkerLocation temp_ml = new();

                    foreach (var m_gt in m_MarkersGroundTruth)
                    {
                        if (Equals(markers[i].custom_name, m_gt.name))
                        {
                            temp_ml.Marker_name = markers[i].custom_name;

                            var gt_m44 = GlobalConfig.GetM44ByGameObjRef(m_gt, origin);
                            temp_obj.transform.localPosition = GlobalConfig.GetPositionFromM44(gt_m44);
                            temp_obj.transform.localEulerAngles = GlobalConfig.GetEulerAngleFromM44(gt_m44);

                            temp_ml.GT_Position = GlobalConfig.ExtractVector3(temp_obj.transform.position);
                            temp_ml.GT_EulerAngle = GlobalConfig.ExtractVector3(temp_obj.transform.eulerAngles);

                            temp_ml.C_Position = GlobalConfig.ExtractVector3(markers[i].custom_position);
                            temp_ml.C_EulerAngle = GlobalConfig.ExtractVector3(markers[i].custom_euler_rotation);

                            m_Markers.Add(temp_ml);
                            break;
                        }
                    }
                }
            }

            // update current marker in the list
            for (int i = 0; i < markers.Count; i++)
            {
                for (int j = 0; j < m_Markers.Count; j++)
                {
                    if (Equals(markers[i].custom_name, m_Markers[j].Marker_name))
                    {
                        m_Markers[j].C_Position = GlobalConfig.ExtractVector3(markers[i].custom_position);
                        m_Markers[j].C_EulerAngle = GlobalConfig.ExtractVector3(markers[i].custom_euler_rotation);

                        break;
                    }
                }
            }

            Destroy(temp_obj);
        }

        void AddOrUpdateCameraData(List<CustomTransform> runtime_markers, string previous_marker)
        {            
            // add new camera trajectory data
            if (m_CameraTrajectoryData.Count < m_Markers.Count)
            {
                foreach (var m in runtime_markers)
                {
                    CameraTrajectoryData data = new();
                    data.Marker_name = m.custom_name;
                    data.Camera_travel_distance = CTT.GetCameraDistance();
                    data.Camera_travel_time = CTT.GetTotalTime();
                    data.Previous_marker = previous_marker;

                    CTT.SetNowMarkerName(m.custom_name);
                    m_CameraTrajectoryData.Add(data);

                    break;
                }
            }

            // update current marker in the list
            foreach (var rt_m in runtime_markers)
            {
                foreach (var ctd in m_CameraTrajectoryData)
                {
                    if (Equals(rt_m.custom_name, ctd.Marker_name))
                    {
                        ctd.Camera_travel_distance = CTT.GetCameraDistance();
                        ctd.Camera_travel_time = CTT.GetTotalTime();
                        ctd.Previous_marker = CTT.GetPrevMarkerName();

                        break;
                    }
                }
            }

            // UPDATE: December 17th, 2022
            // - replaced by above
            //// add new camera trajectory data
            //if (m_CameraTrajectoryData.Count < markers.Count)
            //{
            //    #pragma warning disable CS0162 // Unreachable code detected
            //    for (int i = m_CameraTrajectoryData.Count; i < markers.Count; i++)
            //    #pragma warning restore CS0162 // Unreachable code detected
            //    {
            //        CameraTrajectoryData data = new();
            //        data.Marker_name = markers[i].custom_name;
            //        data.Camera_travel_distance = CTT.GetCameraDistance();
            //        data.Camera_travel_time = CTT.GetTotalTime();
            //        data.Previous_marker = CTT.GetPrevMarkerName();

            //        CTT.SetNowMarkerName(markers[i].custom_name);
            //        m_CameraTrajectoryData.Add(data);

            //        break;
            //    }
            //}

            //// update current marker in the list
            //for (int i = 0; i < m_CameraTrajectoryData.Count; i++)
            //{
            //    for (int j = 0; j < markers.Count; j++)
            //    {
            //        if (Equals(m_CameraTrajectoryData[i].Marker_name, markers[j].custom_name))
            //        {
            //            m_CameraTrajectoryData[i].Camera_travel_distance = CTT.GetCameraDistance();
            //            m_CameraTrajectoryData[i].Camera_travel_time = CTT.GetTotalTime();
            //            m_CameraTrajectoryData[i].Previous_marker = CTT.GetPrevMarkerName();

            //            break;
            //        }
            //    }
            //}

            var s = "";
            foreach (var m in m_CameraTrajectoryData)
            {
                s += m.Marker_name + "\n";
                s += m.Camera_travel_distance + "\n";
                s += m.Camera_travel_time + "\n";
                s += m.Previous_marker + "\n";
                s += "\n";
            }
            //Debug.Log(s);
        }

        void ImportObjectsNewARScene()
        {
            m_Objects = m_LoadObjectManager
                .GetComponent<LoadObject_CatExample_2__NewARScene>()
                .GetMyObjects();

            m_InitObjectsLocations = new();
            foreach (var o in m_Objects)
            {
                m_InitObjectsLocations.Add(GlobalConfig.ExtractVector3(o.transform.position));
            }
        }

        void GetMarkerGroundTruth()
        {
            m_MarkersGroundTruth = new();

            var parents = m_LoadObjectManager
                .GetComponent<LoadObject_CatExample_2__NewARScene>()
                .GetMyParents();
            foreach (var item in parents)
            {
                string[] names = item.name.Split("_");
                if (names[0] == "img")
                    m_MarkersGroundTruth.Add(item);
            }
        }

        List<float> GetPriority(bool normalized, params float[] priorities)
        {
            List<float> norm_priority = new();

            // add them into List
            for (int i = 0; i < priorities.Length; i++)
            {
                norm_priority.Add(priorities[i]);
            }

            // return normalized
            if (normalized) return MathFunctions.NormalizedMany(norm_priority);
            else return norm_priority;
        }

        void TestAdding(List<float[]> a, List<float[]> b)
        {
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(a),
                "Left operand before adding on Version 2a");
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(b),
                "Right operand before adding on Version 2a");

            var adding_result = MathFunctions.AddTwoListFloatArray(a, b);
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(adding_result),
                "Final result after adding on Version 2a");

            List<float[]> result_normalized = new();
            foreach (var ar in adding_result)
            {
                result_normalized.Add(MathFunctions.NormalizedMany(ar));
            }
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(result_normalized),
                "Normalized after adding on Version 2a");
        }

        void TestAdding(WeightsAndScalar a, WeightsAndScalar b)
        {
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(a.Weights),
                "Left operand before adding on Version 2a");
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(b.Weights),
                "Right operand before adding on Version 2a");

            var adding_result = MathFunctions.AddTwoListFloatArray(a.Weights, b.Weights);
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(adding_result),
                "Final result after adding on Version 2a");

            List<float[]> result_normalized = new();
            foreach (var ar in adding_result)
            {
                result_normalized.Add(MathFunctions.NormalizedMany(ar));
            }
            GlobalDebugging.DebugLogListFloatArray(Test_OnlyAxisObjectGet.AxisForDec192022(result_normalized),
                "Normalized after adding on Version 2a");
        }
    }
}
